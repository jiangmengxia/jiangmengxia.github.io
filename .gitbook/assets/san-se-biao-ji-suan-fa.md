<!--
 * @Author: jiangmengxia jiangmengxia@qq.com
 * @Date: 2024-09-09 21:25:30
 * @LastEditors: jiangmengxia jiangmengxia@qq.com
 * @LastEditTime: 2024-09-09 22:07:11
 * @FilePath: /jiangmengxia.github.io/.gitbook/assets/san-se-biao-ji-suan-fa.md
 * @Description: Description
-->
# 三色标记算法

## 前言

三色标记法是一种用于垃圾回收的标记算法，主要用于标记可达对象。可达对象是指从根对象（通常是全局对象）可以到达的对象。

三色标记法，用于垃圾回收器升级，将STW变为并发标记，STW就是在标记垃圾的时候，必须暂停主程序。而使用并发标记，就是程序一边运行，一边回收垃圾。

## 什么是三色
首先我们需要知道，三色标记法根据可达性分析，从GC Root开始进行遍历访问，在遍历对象过程中，将对象分为三种颜色：

* 白色：白色对象表示尚未被标记的对象。初始时，所有对象都是白色的。当可达性分析结束的阶段，仍是白色对象，即代码不可达，则可以全部回收。

* 灰色：灰色对象表示已经被标记，但它的引用对象尚未被全部标记。

* 黑色：黑色对象表示已经被标记，且它的引用对象也已经被标记的对象。

## 标记过程

三色标记法的标记过程如下：
![alt text](<../../.gitbook/assets/三色标记过程.png>)

1. 初始时，所有对象都在【白色集合】中
2. 将GC Roots直接引用到的对象都挪到【灰色集合】中
3. 从灰色集合中获取对象
   3.1 将本对象引用到的其他对象全部挪到【灰色集合】中
   3.2 将本对象挪到【黑色集合】中
4. 重复步骤3，直至【灰色集合】为空时结束
5. 结束后，仍在【白色集合】的对象，即为GC roots不可达，可以进行回收。

需要注意，传统标记方式发生Stop The World时，对象间的引用是不会发生变化的，可以轻松完成标记。
而并发标记在标记期间应用现场还在继续跑，对象建的引用可能发生变化，就可能会出现错标和漏标的情况。

## 存在的问题

### 错标 - 浮动垃圾：标记过不是垃圾的变成了垃圾

![alt text](<../../.gitbook/assets/三色标记过程-错标.png>)

并发标记过程中，若一个已经被标记成黑色或灰色的对象，突然变成了垃圾，此时此对象不是白色的，不会被消除，
重新标记也不能从GC Root中去找到，所以形成了浮动垃圾，这种情况对系统影响不大，留给下一次GC进行处理即可。

### 漏标 --需要的对象被回收
![alt text](<../../.gitbook/assets/三色标记-漏标.png>)

并发过程中，一个业务线程将一个被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用），（这两部分可以不分先后顺序）；

因为黑色对象的含义为其属性都已经标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被GC回收，此问题会导致系统问题。


### 解决方案
三色标记法通常会结合`写屏障`（Write Barrier）。

写屏障是一种在对象引用被修改时触发的机制。当黑色对象引用了一个新的对象时，写屏障会记录这个新的对象，并在标记过程结束后重新标记这个新的对象。这样，即使黑色对象引用了一个新的对象，也不会产生浮动垃圾。

# 术语
STW：（Stop-The-World）是垃圾回收中的一个术语，指的是垃圾回收器在执行垃圾回收时，会暂停应用程序的所有线程。在STW期间，应用程序的所有线程都会停止执行，直到垃圾回收完成。

STW的主要目的是确保垃圾回收器在执行垃圾回收时，不会出现数据不一致的问题。例如，如果垃圾回收器在标记阶段发现一个对象被两个线程同时修改，那么垃圾回收器就无法确定这个对象是否应该被回收。为了避免这种情况，垃圾回收器在标记阶段会暂停所有线程，确保对象的状态在标记阶段是一致的。

STW的缺点是会降低应用程序的性能，因为应用程序的所有线程都会停止执行。为了减少STW对性能的影响，现代的垃圾回收器通常会采用一些优化策略，例如并发标记（Concurrent Marking）和增量标记（Incremental Marking）。这些策略可以在不暂停所有线程的情况下，尽可能多地并发执行垃圾回收操作，从而减少STW的时间。