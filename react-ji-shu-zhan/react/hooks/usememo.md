# useMemo

它的行为非常类似Vue中的计算属性，它仅会在某个依赖项改变时重新计算，并且返回一个计算结果，称memoized（记忆的）值。如果依赖项并未更新，则也不会重新计算，从而有助于避免在每个渲染上进行昂贵的计算。

缺点：

&#x20;(1) 代码可读性差：useMemo 的代码更臃肿，可读性较差，因为它将多个生命周期函数合并为一个函数，使得代码难以理解。&#x20;

(2) 依赖管理复杂：useMemo 的依赖管理比较复杂，需要仔细管理依赖数组中的变量，否则可能会导致副作用执行不正确。

&#x20;(3) 性能问题：当依赖数组中的变量更新时，useMemo 会执行副作用，这可能会导致不必要的副作用执行，从而影响性能。因此，在使用 useMemo 时，需要注意依赖数组中的变量，避免不必要的副作用执行。
